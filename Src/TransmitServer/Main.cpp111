#include "Common/PrintLog.h"
#include "Common/RPCDef.h"
#include "Poco/Types.h"
#include "Poco/Net/SocketAddress.h"
#include "Poco/Net/ServerSocket.h"
#include "Poco/Net/Context.h"
#include "Poco/Net/SecureServerSocket.h"
#include "Poco/Net/SocketImpl.h"
#include "Poco/Net/StreamSocket.h"
#include "Poco/Net/StreamSocketImpl.h"
#include "Poco/Timespan.h"
#include "Poco/Dynamic/Var.h"
#include "Poco/JSON/Parser.h"
#include "Poco/JSON/Object.h"
#include "Poco/MD5Engine.h"
using namespace Poco;
using namespace Poco::Net;
int main(int argc, char** argv)
{
	if(argc < 3)
	{
		errorf("%s, %d: argc < 3\n", __FILE__, __LINE__);
		return -1;
	}
	initializeSSL();
	UInt16 ssl_port = atoi(argv[1]);
	UInt16 port = atoi(argv[2]);
	SocketAddress clientAddr;
	Context::Ptr pContext = NULL;
	try
	{
	pContext = new Context(Context::TLSV1_SERVER_USE,
										"./privkey.pem",
										"./cert.pem",
										"", 
										Context::VERIFY_NONE);
	}
	catch(Exception& e)
	{
		printf("%s\n", e.message().c_str());
		exit(0);
	}
	SecureServerSocket ssl_sock(ssl_port, 64, pContext);
	SocketImpl* ss_impl;
	StreamSocket* ssl_stream_sock = NULL;
	{
		SocketImpl* temp_sock = ssl_sock.impl();
		ss_impl = temp_sock->acceptConnection(clientAddr);
		ssl_stream_sock = new StreamSocket(ss_impl);
	}
	tracef("%s, %d: Receive ssl connection from %s.\n", __FILE__, __LINE__, clientAddr.toString().c_str());
	Timespan ts(5, 0);
	char buf[512] = {0, };
	ssl_stream_sock->setReceiveTimeout(ts);
	if(ssl_stream_sock->poll(ts, Socket::SELECT_READ) > 0)
	{
		try
		{
			if(ssl_stream_sock->receiveBytes(buf, sizeof(buf)) > 0)
			  tracef("%s, %d: Receive data: %s.\n", __FILE__, __LINE__, buf);
		}
		catch(Exception& e)
		{
			errorf("%s, %d: %s.\n", __FILE__, __LINE__, e.message().c_str());
			return -1;
		}
	}
	JSON::Parser parser;
	Dynamic::Var token_request = parser.parse(buf);
	JSON::Object::Ptr obj = token_request.extract<JSON::Object::Ptr>();
	token_request = obj->get("key");
	if("alpha2015" != token_request.toString())
	{
		errorf("%s, %d: Key error.\n", __FILE__, __LINE__);
	}
	memset(buf, 0 ,sizeof(buf));
	std::string token = "asdh7123jds9f12834asd81238bs0ub14h8";
	snprintf(buf, sizeof(buf) - 1, "%s", token.c_str());
	if(ssl_stream_sock->sendBytes(buf, sizeof(buf)) > 0)
	{
		tracef("%s, %d: Send token: %s.\n", __FILE__, __LINE__, buf);
	}
	else
	{
		errorf("%s, %d: Send token failed.\n", __FILE__, __LINE__);
		return -1;
	}
	ServerSocket ss(port);
	StreamSocket sock = ss.acceptConnection(clientAddr);
	tracef("%s, %d: Receive connection from: %s.\n", __FILE__, __LINE__, clientAddr.toString().c_str());
	sock.setReceiveTimeout(ts);
	memset(buf, 0, sizeof(buf));
	if(sock.poll(ts, Socket::SELECT_READ))
	{
		try
		{
			if(sock.receiveBytes(buf, sizeof(buf)) > 0)
				tracef("%s, %d: Receive data: %s.\n", __FILE__, __LINE__, buf);
		}
		catch(Exception& e)
		{
			errorf("%s, %d: Receive exception.\n", __FILE__, __LINE__);
			return -1;
		}
	}
	parser.reset();
	Dynamic::Var result = parser.parse(buf);
	JSON::Object::Ptr object = result.extract<JSON::Object::Ptr>();
	result = object->get("token");
	if(token != result.toString())
	{
		errorf("%s, %d: token not equal.\n", __FILE__, __LINE__);
		return -1;
	}
	memset(buf, 0 ,sizeof(buf));
	snprintf(buf, sizeof(buf) - 1, "200 OK");
	if(sock.sendBytes(buf, strlen(buf)) > 0)
	{
		tracef("%s, %d: Send response.\n", __FILE__, __LINE__);
	}

	{
		DynamicStruct ds;
		ds[KEY_TYPE_STR] = TYPE_REQUEST_STR;
		std::string component = COMPONENT_USER_STR;
		std::string method = USER_METHOD_LOGIN;
		ds[KEY_ACTION_STR] = component + "." + method;
		DynamicStruct param;
		param[PARAM_USERNAME_STR] = "hj";
		//param[PARAM_PASSWORD_STR] = "huangjian";
		ds[KEY_PARAM_STR] = param;
		memset(buf, 0 , sizeof(buf));
		snprintf(buf, sizeof(buf) - 1, "%s", ds.toString().c_str());
	}
	tracef("send:%s\n", buf);
	Thread::sleep(1000);
	int ret = sock.sendBytes(buf, strlen(buf));
	if(ret > 0)
	{
		tracef("send login:%d.\n", ret);
	}
	sock.poll(ts, Socket::SELECT_READ);
	if(sock.receiveBytes(buf, sizeof(buf)) > 0)
	{
		tracef("%s, %d: Receive data: %s.\n", __FILE__, __LINE__, buf);
	}
	{
		parser.reset();
		Dynamic::Var result = parser.parse(buf);
		DynamicStruct ds;
		JSON::Object::Ptr obj;
		obj = result.extract<JSON::Object::Ptr>();
		ds = *obj;
		std::string challenge = ds[KEY_PARAM_STR][PARAM_CHALLENGE_STR];
		std::string token = ds[KEY_PARAM_STR][PARAM_TOKEN_STR];
		MD5Engine md5;
		md5.update("huangjian");
		const DigestEngine::Digest& digest = md5.digest();
		std::string md5password = DigestEngine::digestToHex(digest);
		std::string verify = md5password + challenge;
		md5.update(verify);
		const DigestEngine::Digest& digest2 = md5.digest();
		verify = DigestEngine::digestToHex(digest2);

		DynamicStruct param;
		param[PARAM_USERNAME_STR] = "hj";
		param[PARAM_PASSWORD_STR] = verify;
		param[PARAM_TOKEN_STR] = token;
		ds[KEY_TYPE_STR] = TYPE_REQUEST_STR;
		std::string component = COMPONENT_USER_STR;
		std::string method = USER_METHOD_LOGIN;
		ds[KEY_ACTION_STR] = component +"." + method;
		ds[KEY_PARAM_STR] = param;

		snprintf(buf, sizeof(buf) - 1, "%s", ds.toString().c_str() );
	}
	tracef("send:%s\n", buf);
	sock.sendBytes(buf, strlen(buf));

	while(1)
	{
		if(sock.poll(ts, Socket::SELECT_READ))
		{
			memset(buf, 0, sizeof(buf));
			try
			{
				if(sock.receiveBytes(buf, sizeof(buf)) > 0)
				tracef("%s, %d: Receive data: %s.\n", __FILE__, __LINE__, buf);
			}
			catch(Exception& e)
			{
				errorf("%s, %d: Receive exception.\n", __FILE__, __LINE__);
			}
		}
	}
	uninitializeSSL();
	ssl_sock.close();
	sock.close();
	ss.close();	
	return 0;
}
